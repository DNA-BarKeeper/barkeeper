# frozen_string_literal: true

module Export
  extend ActiveSupport::Concern

  PDE_BEGINNING = '<?xml version="1.0" standalone="no"?>'\
                  "<!-- Generated by GBOL5 web app #{Time.zone.now}  -->"\
                  '<phyde id="wL6obVNH1kuwviaB" version="0.994">'\
                  '<description></description>'

  PDE_CLOSURE = '</block></matrix></alignment></phyde>'

  module ClassMethods
    def pde(contigs, add_reads)
      @pde_header = "<header><entries>32 \"Species\" STRING\n33 \"GBOL5 URL\" STRING</entries>"

      pde_matrix = +''
      @height = 0 # Number of lines (needed for pde dimensions)
      @max_width = 0 # Number of alignment columns
      @block_seqs = [] # Collect sequences for block, later fill with '?' up to max_width

      contigs.each do |contig|
        species = contig.try(:isolate).try(:individual).try(:species)&.composed_name
        contig_name = species.blank? ? contig.name : [contig.name, species.gsub(' ', '_')].join('_')

        contig.partial_cons.each do |partial_con|
          aligned_sequence = partial_con.aligned_sequence.nil? ? '' : partial_con.aligned_sequence

          partial_con.primer_reads.each { |read| add_primer_read_to_pde(read, true) } if add_reads

          add_sequence_to_pde(contig_name, species, routes.edit_contig_url(contig, url_options), aligned_sequence, true)
        end

        next unless add_reads

        # Add unassembled reads:
        contig.primer_reads.not_assembled.each { |read| add_primer_read_to_pde(read, false) } if (contig.primer_reads.not_assembled.count > 0)

        contig.primer_reads.not_used_for_assembly.each { |read| add_primer_read_to_pde(read, false) } if (contig.primer_reads.not_used_for_assembly.count > 0)

        contig.primer_reads.not_trimmed.each { |read| add_primer_read_to_pde(read, false) } if (contig.primer_reads.not_trimmed.count > 0)

        contig.primer_reads.unprocessed.each { |read| add_primer_read_to_pde(read, false) } if (contig.primer_reads.unprocessed.count > 0)
      end

      @pde_header += "</header>\n"

      pde_dimensions = "<alignment datatype=\"dna\" width=\"#{@max_width}\" height=\"#{@height}\" gencode=\"0\" offset=\"-1\">"

      pde_matrix_dimensions = "<block x=\"0\" y=\"0\" width=\"#{@max_width}\" height=\"#{@height}\">"

      @block_seqs.each do |seq|
        (@max_width - seq.length).times { seq += '?' }
        pde_matrix += "#{seq}\\FF\n"
      end

      PDE_BEGINNING + pde_dimensions + @pde_header + '<matrix>' + pde_matrix_dimensions + pde_matrix + PDE_CLOSURE
    end

    # TODO: Unfinished feature (contigs)
    # def zip_archive
    #   # Only create new archive if no recent one exists
    #   if !search_result_archive.present? || search_result_archive_updated_at < (Time.now - 24.hours).utc
    #     archive_name = title.empty? ? "contig_search_#{created_at}" : title
    #     archive_file = "#{archive_name}.zip"
    #
    #     # Create archive file
    #     Zip::File.open(archive_file, Zip::File::CREATE) do |archive|
    #       contigs.includes(:primer_reads, partial_cons: :primer_reads).each do |contig|
    #         # Write contig PDE to a file and add this to the zip file
    #         pde_file_name = "#{contig.name}.pde"
    #         archive.get_output_stream(pde_file_name) { |file| file.write(contig.as_pde) }
    #
    #         # Write chromatogram to a file and add this to the zip file
    #         contig.primer_reads.each do |read|
    #           archive.get_output_stream(read.file_name_id) { |file| file.write(URI.parse("http:#{read.chromatogram.url}").read) }
    #         end
    #       end
    #     end
    #
    #     # Upload created archive
    #     file = File.open(archive_file)
    #     self.search_result_archive = file
    #     file.close
    #     save!
    #   end
    # end

    private

    def routes
      Rails.application.routes.url_helpers
    end

    def url_options
      ActionMailer::Base.default_url_options
    end

    def add_sequence_to_pde(name, species, url, sequence, is_contig)
      sequence = sequence ? sequence : ''

      @pde_header += "<seq idx=\"#{@height}\">"\
                   "<e id=\"1\">#{name}</e>"

      @pde_header += "<e id=\"2\">#{name}</e>" unless is_contig

      @pde_header += "<e id=\"32\">#{species}</e>" if is_contig

      @pde_header += "<e id=\"33\">#{url}</e>"\
                     "</seq>\n"

      @block_seqs << sequence
      @height += 1

      @max_width = sequence.length if sequence.length > @max_width
    end

    def add_primer_read_to_pde(primer_read, assembled)
      sequence = assembled ? primer_read.aligned_seq : primer_read.sequence
      add_sequence_to_pde(primer_read.file_name_id, '', routes.edit_primer_read_url(primer_read, url_options), sequence, false)
    end
  end


  def as_fas
    fas_str=""
    ctr=0
    self.partial_cons.each do |partial_con|

      partial_con.primer_reads.each do |read|
        fas_str+= ">#{read.name}\n"
        fas_str+= "#{read.aligned_seq}\n"
      end

      if self.partial_cons.count > 1
        fas_str+= ">#{self.name} - consensus #{ctr+1}\n"
      else
        fas_str+= ">#{self.name} - consensus\n"
      end
      fas_str+=partial_con.aligned_sequence
      ctr+=1
    end
    fas_str
  end

  def as_fasq(mira)

    use_mira=false

    if mira == "1" or mira == 1
      use_mira=true
    end

    # restrict to cases with partial_cons count == 1
    if self.partial_cons.count > 1 or self.partial_cons.count < 1
      puts "Must have 1 partial_cons."
      return
    end

    pc = self.partial_cons.first

    # compute coverage

    used_nucleotides_count=0

    pc.primer_reads.each do |r|
      used_nucleotides_count += (r.aligned_seq.length - r.aligned_seq.count('-'))
    end

    coverage =(used_nucleotides_count.to_f/pc.aligned_sequence.length)

    # header

    fasq_str = "@#{self.name} | #{sprintf '%.2f', coverage}"

    # seq

    raw_cons = pc.aligned_sequence

    # seq_no_gaps = raw_cons.gsub(/-/, '') #-> does not work like this, quality score array may contain > 0 values where cons. has gap

    cons_seq=''
    qual_str=''

    ctr=0

    if use_mira
      qualities_to_use=pc.aligned_qualities
    else
      qualities_to_use=pc.mira_consensus_qualities
    end

    qualities_to_use.each do |q|
      if q > 0
        cons_seq += raw_cons[ctr]
        qual_str+= (q+33).chr
        ctr+=1
      end
    end


    #check that seq + qual have same length -> for externally verified this needs not be true

    unless cons_seq.length == qual_str.length
      puts "Error: seq (#{seq_no_gaps.length}) + qual (#{ctr}) do not have same length"
      return
    end

    "#{fasq_str}\n#{cons_seq}\n+\n#{qual_str}\n"

  end
end
