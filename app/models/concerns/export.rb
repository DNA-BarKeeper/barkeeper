# frozen_string_literal: true

module Export
  extend ActiveSupport::Concern

  PDE_BEGINNING = '<?xml version="1.0" standalone="no"?>'\
                  "<!-- Generated by GBOL5 web app #{Time.zone.now}  -->"\
                  '<phyde id="wL6obVNH1kuwviaB" version="0.994">'\
                  '<description></description>'

  PDE_CLOSURE = '</block></matrix></alignment></phyde>'

  module ClassMethods
    def pde(contigs, add_reads)
      @pde_header = '<header><entries>32 "GBOL5 URL" STRING</entries>'

      pde_matrix = +''
      @height = 0 # Number of lines (needed for pde dimensions)
      @max_width = 0 # Number of alignment columns
      @block_seqs = [] # Collect sequences for block, later fill with '?' up to max_width

      contigs.each do |contig|
        contig.partial_cons.each do |partial_con|
          aligned_sequence = partial_con.aligned_sequence.nil? ? '' : partial_con.aligned_sequence

          partial_con.primer_reads.each { |read| add_primer_read_to_pde(read) } if add_reads

          add_sequence_to_pde(contig.name, routes.edit_contig_url(contig, url_options), aligned_sequence, true)
        end

        next unless add_reads

        # Add all reads that are not part of any partial con:
        contig.primer_reads.not_assembled.each { |read| add_primer_read_to_pde(read) } if (contig.primer_reads.not_assembled.count > 0)

        contig.primer_reads.not_used_for_assembly.each { |read| add_primer_read_to_pde(read) } if (contig.primer_reads.not_used_for_assembly.count > 0)

        contig.primer_reads.not_trimmed.each { |read| add_primer_read_to_pde(read) } if (contig.primer_reads.not_trimmed.count > 0)

        contig.primer_reads.unprocessed.each { |read| add_primer_read_to_pde(read) } if (contig.primer_reads.unprocessed.count > 0)
      end

      @pde_header += "</header>\n"

      pde_dimensions = "<alignment datatype=\"dna\" width=\"#{@max_width}\" height=\"#{@height}\" gencode=\"0\" offset=\"-1\">"

      pde_matrix_dimensions = "<block x=\"0\" y=\"0\" width=\"#{@max_width}\" height=\"#{@height}\">"

      @block_seqs.each do |seq|
        (@max_width - seq.length).times { seq += '?' }
        pde_matrix += "#{seq}\\FF\n"
      end

      PDE_BEGINNING + pde_dimensions + @pde_header + '<matrix>' + pde_matrix_dimensions + pde_matrix + PDE_CLOSURE
    end

    private

    def routes
      Rails.application.routes.url_helpers
    end

    def url_options
      ActionMailer::Base.default_url_options
    end

    def add_sequence_to_pde(name, url, sequence, is_contig)
      @pde_header += "<seq idx=\"#{@height}\">"\
                   "<e id=\"1\">#{name}</e>"

      @pde_header += "<e id=\"2\">#{name}</e>" unless is_contig

      @pde_header += "<e id=\"32\">#{url}</e>"\
                   "</seq>\n"

      @block_seqs << sequence
      @height += 1

      @max_width = sequence.length if sequence.length > @max_width
    end

    def add_primer_read_to_pde(primer_read)
      add_sequence_to_pde(primer_read.file_name_id, routes.edit_primer_read_url(primer_read, url_options), primer_read.aligned_seq, false)
    end
  end


  def as_fas
    fas_str=""
    ctr=0
    self.partial_cons.each do |partial_con|

      partial_con.primer_reads.each do |read|
        fas_str+= ">#{read.name}\n"
        fas_str+= "#{read.aligned_seq}\n"
      end

      if self.partial_cons.count > 1
        fas_str+= ">#{self.name} - consensus #{ctr+1}\n"
      else
        fas_str+= ">#{self.name} - consensus\n"
      end
      fas_str+=partial_con.aligned_sequence
      ctr+=1
    end
    fas_str
  end

  def as_fasq(mira)

    use_mira=false

    if mira == "1" or mira == 1
      use_mira=true
    end

    # restrict to cases with partial_cons count == 1
    if self.partial_cons.count > 1 or self.partial_cons.count < 1
      puts "Must have 1 partial_cons."
      return
    end

    pc = self.partial_cons.first

    # compute coverage

    used_nucleotides_count=0

    pc.primer_reads.each do |r|
      used_nucleotides_count += (r.aligned_seq.length - r.aligned_seq.count('-'))
    end

    coverage =(used_nucleotides_count.to_f/pc.aligned_sequence.length)

    # header

    fasq_str = "@#{self.name} | #{sprintf '%.2f', coverage}"

    # seq

    raw_cons = pc.aligned_sequence

    # seq_no_gaps = raw_cons.gsub(/-/, '') #-> does not work like this, quality score array may contain > 0 values where cons. has gap

    cons_seq=''
    qual_str=''

    ctr=0

    if use_mira
      qualities_to_use=pc.aligned_qualities
    else
      qualities_to_use=pc.mira_consensus_qualities
    end

    qualities_to_use.each do |q|
      if q > 0
        cons_seq += raw_cons[ctr]
        qual_str+= (q+33).chr
        ctr+=1
      end
    end


    #check that seq + qual have same length -> for externally verified this needs not be true

    unless cons_seq.length == qual_str.length
      puts "Error: seq (#{seq_no_gaps.length}) + qual (#{ctr}) do not have same length"
      return
    end

    "#{fasq_str}\n#{cons_seq}\n+\n#{qual_str}\n"

  end
end
