# write SPECIMENS & STATUS  to Excel-XML (xls) for use by ZFMK for their "Portal / db : bolgermany.de "

class XmlUploader < ActiveRecord::Base

  #todo later rename  :uploaded_file to xml_File or s.th.

  has_attached_file :uploaded_file,
                    :storage => :s3,
                    :s3_credentials => Proc.new{ |a| a.instance.s3_credentials },
                    :path => "/specimens.xls"

  # Validate content type
  validates_attachment_content_type :uploaded_file, :content_type => /\Aapplication\/xml/

  # Validate filename
  validates_attachment_file_name :uploaded_file, :matches => [/xls\Z/]

  def create_uploaded_file

    file_to_upload = File.open("specimens.xls", "w")

    file_to_upload.write(xml_string)
    file_to_upload.close
    self.uploaded_file = File.open("specimens.xls")
    self.save!

    # puts xml_string
  end

  #todo remove s3 credentials from code everywhere

  def s3_credentials
    {:bucket => "gbol5", :access_key_id => "AKIAINH5TDSKSWQ6J62A", :secret_access_key => "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"}
  end

  def xml_string
    # get all indiv.
    @individuals=Individual.includes(:species => :family).all #alternativ: find_in_batches

    @states=["Baden-Württemberg","Bayern","Berlin","Brandenburg","Bremen","Hamburg","Hessen","Mecklenburg-Vorpommern","Niedersachsen","Nordrhein-Westfalen","Rheinland-Pfalz","Saarland","Sachsen","Sachsen-Anhalt","Schleswig-Holstein","Thüringen"]

    @header_cells = ["GBOL5 specimen ID",
                     "Feldnummer",
                     "Institut",
                     "Sammlungs-Nr.",
                     "Familie",
                     "Taxon-Name",
                     "Erstbeschreiber Jahr",
                     "evtl. Bemerkung Taxonomie",
                     "Name",
                     "Datum",
                     "Gewebetyp und Menge",
                     "Anzahl Individuen",
                     "Fixierungsmethode"   ,
                     "Entwicklungsstadium",
                     "Sex",
                     "evtl. Bemerkungen zur Probe",
                     "Fundortbeschreibung",
                     "Region",
                     "Bundesland",
                     "Land",
                     "Datum",
                     "Sammelmethode",
                     "Breitengrad",
                     "Längengrad",
                     "Benutzte Methode",
                     "Ungenauigkeitsangabe",
                     "Höhe/Tiefe [m]",
                     "Habitat",
                     "Sammler",
                     "Nummer",
                     "Behörde"
    ]

    Marker.gbol_marker.each do |m|
      @header_cells << "#{m.name} - URL"
      @header_cells << "#{m.name} - Marker Sequence"
      @header_cells << "#{m.name} - Sequences Withhold"
    end

    builder = Nokogiri::XML::Builder.new do |xml|

      xml.comment("Generated by gbol5.de web app on #{Time.zone.now}")
      xml.Workbook('xmlns'=>"urn:schemas-microsoft-com:office:spreadsheet",
                   'xmlns:o'=>"urn:schemas-microsoft-com:office:office",
                   'xmlns:x'=>"urn:schemas-microsoft-com:office:excel",
                   'xmlns:ss'=>"urn:schemas-microsoft-com:office:spreadsheet",
                   'xmlns:html'=>"http://www.w3.org/TR/REC-html40") {
        xml.Worksheet('ss:Name'=>"Sheet1") {
          xml.Table {
            xml.Row{

              @header_cells.each do |o|
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(o)
                  }
                }
              end

            }
            #@individuals.each do |individual|
            @individuals.take(25).each do |individual| # nur zu testzwecken, alternativ: find in batches
              xml.Row{
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    #previous version with "Gbol-Nr.":
                    # xml.text(individual.try(:isolates).first.try(:lab_nr))
                    xml.text(individual.id)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    if individual.collection_nr
                      if individual.collection_nr.include? 's.n.' or individual.collection_nr.include? 's. n.'
                        xml.text('')
                      else
                        xml.text(individual.collection_nr)
                      end
                    end
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.herbarium)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    if individual.specimen_id == "<no info available in DNA Bank>"
                      xml.text('')
                    else
                      xml.text(individual.specimen_id)
                    end
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.try(:species).try(:family).try(:name))
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.try(:species).try(:name_for_display))
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.try(:species).try(:author))
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.determination)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('Blattmaterial')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('Silica gel')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text("gbol5.de/individuals/#{individual.id}/edit")
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.locality)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {

                    if individual.country == 'Germany' or individual.country == 'Deutschland'
                      # tests first if is a Bundesland; outputs nothing if other crap was entered in this field:

                      if @states.include? individual.state_province
                        xml.text(individual.state_province)
                      else
                        xml.text('')
                      end

                      # stuff from Schweiz etc
                    else
                      xml.text('Europa')
                    end
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.country)
                  }
                }

                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.collection_date)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.latitude)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.longitude)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text("")
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.elevation)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.habitat)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.collector)
                  }
                }
                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text(individual.collection_nr)
                  }
                }

                xml.Cell {
                  xml.Data('ss:Type' => "String") {
                    xml.text('')
                  }
                }

                # Find longest marker sequence for given individual
                longest_sequence = ''
                individual.try(:isolates).each do |iso|
                  iso.try(:marker_sequences).each do |marker_sequence| # why are there more than one marker sequences per isolate?
                    if marker_sequence.sequence && (marker_sequence.sequence.length > longest_sequence.length)
                      longest_sequence = marker_sequence.sequence
                    end
                  end
                end
                #welchem marker gehört diese marker sequenz zu?
                # für current marker nach der diesem marker zugeordneten sequenz fragen (isolate.marker_sequences where marker_sequences.id.equals currentmarker.id)
                # url zum contig, das zur längsten markersequenz gehört

                Marker.gbol_marker.each do |marker| #gbol marker des jeweiligen isolats verwenden
                  #URL zum contig in GBOL5 WebApp
                  xml.Cell {
                    xml.Data('ss:Type' => "String") {
                      xml.text(edit_contig_path(marker.contigs.first)) #"gbol5.de/contigs/#{marker.contigs.first.id}/edit"
                    }
                  }

                  #Markersequenz
                  xml.Cell {
                    xml.Data('ss:Type' => "String") {
                      if !longest_sequence.nil? && !longest_sequence.empty?
                        xml.text(longest_sequence)
                      end
                    }
                  }

                  #Sequences withhold
                  xml.Cell {
                    xml.Data('ss:Type' => "String") {
                      if (marker.marker_sequences.length > 0) && (!marker.marker_sequences.first.genbank.nil?)
                        xml.text('0')
                      else
                        xml.text('1')
                      end
                    }
                  }
                end

              }
            end
          }
        }
      }

    end

    builder.to_xml

  end


end